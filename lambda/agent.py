import json
import os
import urllib.request
import urllib.error
import base64
import gzip


# --- SLACK FUNCTION ---
def send_slack_alert(analysis_json):
    """
    Sends a formatted Block Kit message to Slack.
    """
    webhook_url = os.environ.get("SLACK_WEBHOOK_URL")
    if not webhook_url:
        print("‚ö†Ô∏è Slack Webhook URL not configured. Skipping notification.")
        return

    # Construct the Slack message using Block Kit
    slack_message = {
        "blocks": [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "üö® CloudSentry: Incident Detected",
                    "emoji": True,
                },
            },
            {"type": "divider"},
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"*ü§ñ Root Cause Analysis:*\n{analysis_json.get('causa', 'N/A')}",
                },
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"*üõ†Ô∏è Suggested Remediation:*\n{analysis_json.get('solucion', 'N/A')}",
                },
            },
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "Generated by CloudSentry AI Agent"
                    }
                ]
            }
        ]
    }

    req = urllib.request.Request(
        webhook_url,
        data=json.dumps(slack_message).encode("utf-8"),
        headers={"Content-Type": "application/json"},
        method="POST",
    )
    try:
        with urllib.request.urlopen(req) as response:
            if response.getcode() != 200:
                print(f"‚ö†Ô∏è Slack API returned status: {response.getcode()}")
    except Exception as e:
        print(f"‚ùå Failed to send Slack notification: {e}")


# --- MAIN HANDLER ---
def handler(event, context):
    print("ü§ñ CloudSentry Agent triggered.")

    logs_reales = ""
    
    try:
        # 1. DECODE CLOUDWATCH LOGS DATA
        # CloudWatch Logs sends data as a base64 encoded, gzipped JSON string.
        if "awslogs" in event:
            cw_data = event["awslogs"]["data"]
            compressed_payload = base64.b64decode(cw_data)
            uncompressed_payload = gzip.decompress(compressed_payload)
            payload = json.loads(uncompressed_payload)

            # Extract log messages
            log_events = payload.get("logEvents", [])
            # Join all messages into a single text block for context
            logs_reales = "\n".join([e["message"] for e in log_events])
            print(f"üì• Processed {len(log_events)} log events.")
        else:
            # Fallback for manual invocation/testing
            print("‚ö†Ô∏è No 'awslogs' key found. Using manual test data.")
            logs_reales = "ERROR manual simulation: Connection refused at port 8080"

    except Exception as e:
        print(f"‚ùå Error decoding CloudWatch data: {e}")
        return {"statusCode": 400, "body": "Invalid CloudWatch Logs event"}

    # 2. CALL ANTHROPIC API
    api_key = os.environ.get("ANTHROPIC_API_KEY")
    anthropic_version = os.environ.get("ANTHROPIC_VERSION", "2023-06-01")
    
    if not api_key:
        print("‚ùå ANTHROPIC_API_KEY is missing.")
        return {"statusCode": 500, "body": "Server Configuration Error"}

    url = "https://api.anthropic.com/v1/messages"

    headers = {
        "x-api-key": api_key,
        "anthropic-version": anthropic_version,
        "content-type": "application/json",
    }

    # Prompt engineering: Enforce JSON output
    payload_ai = {
        "model": "claude-3-haiku-20240307",
        "max_tokens": 1000,
        "messages": [
            {
                "role": "user",
                "content": f"""
                You are a Site Reliability Engineer (SRE) expert. Analyze the following error log:
                
                <log>
                {logs_reales}
                </log>

                Provide a root cause analysis and a technical solution.
                Your response must be strictly a valid JSON object with exactly these keys: "causa" and "solucion".
                Do not include any markdown formatting (like ```json), just the raw JSON string.
                """
            }
        ],
    }

    try:
        data = json.dumps(payload_ai).encode("utf-8")
        req = urllib.request.Request(url, data=data, headers=headers, method="POST")

        with urllib.request.urlopen(req) as response:
            response_body = json.loads(response.read().decode("utf-8"))
            ai_text = response_body["content"][0]["text"].strip()

            # Attempt to clean potential markdown formatting if the model disobeys
            if ai_text.startswith("```json"):
                ai_text = ai_text[7:]
            if ai_text.endswith("```"):
                ai_text = ai_text[:-3]
            
            ai_text = ai_text.strip()

            try:
                parsed_response = json.loads(ai_text)
            except json.JSONDecodeError:
                print(f"‚ö†Ô∏è AI response was not valid JSON: {ai_text}")
                parsed_response = {
                    "causa": "Analysis completed but format was invalid.",
                    "solucion": ai_text
                }

            # 3. NOTIFY SLACK
            send_slack_alert(parsed_response)

            return {
                "statusCode": 200, 
                "body": json.dumps(parsed_response)
            }

    except Exception as e:
        print(f"‚ùå Error calling AI or processing response: {e}")
        return {"statusCode": 500, "body": str(e)}
